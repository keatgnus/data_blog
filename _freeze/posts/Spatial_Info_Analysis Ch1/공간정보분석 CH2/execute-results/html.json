{
  "hash": "22653c20b81bd1aa0eeb8c27b7002bf4",
  "result": {
    "markdown": "---\ntitle: \"Spatial_Info_Analysis CH1\"\nauthor: \"Seongtaek\"\ndate: \"2023-04-20\"\ncategories: [code, Spatial_Info_Analysis, rstudio]\nimage: \"ch2.png\"\ntoc: true\ntoc-depth: 4\nnumber-sections: true\n---\n\n\n<table align=\"bottom\">\n  <td>\n    <a target=\"_blank\" href=\"공간정보분석-CH2.html\"><img\n    src = r_logo.png />HTML파일로 보기</a>\n  </td>\n</table>\n\n지리 공간 데이터 - 벡터 & 래스터\n\n## 공간 정보 분석 CH2 : Geographic data in R\n\n## 패키지 불러오기\n- sf : 지리 공간 벡터 데이터(vector data) 분석을 위한 패키지\n- raster : 지리 공간 레스터 데이터(raster data)를 처리 및 분석하는데 사용\n- spData :  37개의 지리공간 데이터셋이 내장\n- spDataLarge : 지리 공간 데이터 샘플을 내장\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"sf\")     \n#install.packages(\"raster\") \n#install.packages(\"spData\") \n#install.packages(\"spDataLarge\", repos = \"https://nowosad.github.io/drat/\",type = \"source\")\n\nlibrary(sf)\nlibrary(raster)\nlibrary(spData)\nlibrary(spDataLarge)\n```\n:::\n\n\n\n## 벡터(Vector) 데이터\n\n### sf 패키지\n- Edzer Pebesma, Roger Bivand 등이 2016년 10월에 최초로 오픈소스로 공개하였으며,\n  R로 단순 지리특성 기하 (Simple Feature Geometry) 형태로 지리 벡터 데이터를 인코딩하는 표준화된 방법을 지원\n\n- sf 패키지는 sp 패키지의 기능을 승계하였으며,\n  이에 더해 지리공간 데이터를 읽고 쓰는 'GDAL',\n  지리적 연산을 할 때 사용하는 'GEOS',\n  지도의 투영 변환(projection conversions)과 데이터 변환(datum transformations)을 위한 'PROJ' 와 R과의 인터페이스를 제공\n\n- 선택적으로 지리적 좌표에 대한 구면 기하 연산 (spherical geometry operations) 을 위해 's2' 패키지를 사용\n\n- sf 는 모든 벡터 유형(점,선,면, 다각형)을 지원함(raster는 지원하지 않음)\n\n- sf 패키지의 장점\n    - 지리공간 벡터 데이터를 빠르게 읽고 쓸 수 있음\n    - 지리공간 벡터 데이터 시각화 성능의 고도화(tmap, leaflet, mapview 지리공간 데이터 시각화 패키지가 sf 클래스 지원)\n    - 대부분의 연산에서 sf 객체는 DataFrame 처럼 처리가 가능함\n    - sf 함수들은 '%>%' 연산자와 함께 사용할 수 있고,\n      R의 tidyverse 패키지들과도 잘 작동함(sp 패키지도 spdplyr 패키지를 설치하면 dplyr의 %>% 체인 연산자와 기능을 사용할 수 있음)\n    - sf 함수이름은 'st_' 로 시작하여 상대적으로 일관성이 있고 직관적임\n\n### sf 패키지 확인\n- vignetee(package=””) : 비니에트 함수는 설치된 모든 패키지에 대한 이용가능한 모든 목록을 출력\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# vignette(package = \"sf\") # 이용가능 목록 출력\n# vignette(\"sf1\")          # help창 (소개)\n```\n:::\n\n\n- world 데이터셋은 spData에 의해 제공됨\n\n::: {.cell}\n\n```{.r .cell-code}\nworld %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: 83.23324\nGeodetic CRS:  WGS 84\n# A tibble: 6 × 11\n  iso_a2 name_long conti…¹ regio…² subre…³ type  area_…⁴     pop lifeExp gdpPe…⁵\n  <chr>  <chr>     <chr>   <chr>   <chr>   <chr>   <dbl>   <dbl>   <dbl>   <dbl>\n1 FJ     Fiji      Oceania Oceania Melane… Sove…  1.93e4  8.86e5    70.0   8222.\n2 TZ     Tanzania  Africa  Africa  Easter… Sove…  9.33e5  5.22e7    64.2   2402.\n3 EH     Western … Africa  Africa  Northe… Inde…  9.63e4 NA         NA       NA \n4 CA     Canada    North … Americ… Northe… Sove…  1.00e7  3.55e7    82.0  43079.\n5 US     United S… North … Americ… Northe… Coun…  9.51e6  3.19e8    78.8  51922.\n6 KZ     Kazakhst… Asia    Asia    Centra… Sove…  2.73e6  1.73e7    71.6  23587.\n# … with 1 more variable: geom <MULTIPOLYGON [°]>, and abbreviated variable\n#   names ¹​continent, ²​region_un, ³​subregion, ⁴​area_km2, ⁵​gdpPercap\n```\n:::\n\n```{.r .cell-code}\nnames(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n```\n:::\n\n```{.r .cell-code}\nplot(world)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot\nall\n```\n:::\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nworld_mini <- world[1:2, 1:3]\nworld_mini\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 2 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: -0.95\nGeodetic CRS:  WGS 84\n# A tibble: 2 × 4\n  iso_a2 name_long continent                                                geom\n  <chr>  <chr>     <chr>                                      <MULTIPOLYGON [°]>\n1 FJ     Fiji      Oceania   (((-180 -16.55522, -179.9174 -16.50178, -179.7933 …\n2 TZ     Tanzania  Africa    (((33.90371 -0.95, 31.86617 -1.02736, 30.76986 -1.…\n```\n:::\n:::\n\n\n- 기존 sp에 사용되는 공간 데이터는 sf로 변환을 통해 사용 가능\n  - st_as_sf() : sf로 변환 하는 함수\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sp)\n\nworld_sp <- as(world, Class = \"Spatial\")\nworld_sp %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  iso_a2      name_long     continent region_un        subregion\n1     FJ           Fiji       Oceania   Oceania        Melanesia\n2     TZ       Tanzania        Africa    Africa   Eastern Africa\n3     EH Western Sahara        Africa    Africa  Northern Africa\n4     CA         Canada North America  Americas Northern America\n5     US  United States North America  Americas Northern America\n6     KZ     Kazakhstan          Asia      Asia     Central Asia\n               type    area_km2       pop  lifeExp gdpPercap\n1 Sovereign country    19289.97    885806 69.96000  8222.254\n2 Sovereign country   932745.79  52234869 64.16300  2402.099\n3     Indeterminate    96270.60        NA       NA        NA\n4 Sovereign country 10036042.98  35535348 81.95305 43079.143\n5           Country  9510743.74 318622525 78.84146 51921.985\n6 Sovereign country  2729810.51  17288285 71.62000 23587.338\n```\n:::\n\n```{.r .cell-code}\n### sp → sf 변환 : geometry 정보, 컬럼 추가\nworld_sf <- st_as_sf(world_sp)\nworld_sf %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -18.28799 xmax: 180 ymax: 83.23324\nGeodetic CRS:  WGS 84\n  iso_a2      name_long     continent region_un        subregion\n1     FJ           Fiji       Oceania   Oceania        Melanesia\n2     TZ       Tanzania        Africa    Africa   Eastern Africa\n3     EH Western Sahara        Africa    Africa  Northern Africa\n4     CA         Canada North America  Americas Northern America\n5     US  United States North America  Americas Northern America\n6     KZ     Kazakhstan          Asia      Asia     Central Asia\n               type    area_km2       pop  lifeExp gdpPercap\n1 Sovereign country    19289.97    885806 69.96000  8222.254\n2 Sovereign country   932745.79  52234869 64.16300  2402.099\n3     Indeterminate    96270.60        NA       NA        NA\n4 Sovereign country 10036042.98  35535348 81.95305 43079.143\n5           Country  9510743.74 318622525 78.84146 51921.985\n6 Sovereign country  2729810.51  17288285 71.62000 23587.338\n                        geometry\n1 MULTIPOLYGON (((-180 -16.55...\n2 MULTIPOLYGON (((33.90371 -0...\n3 MULTIPOLYGON (((-8.66559 27...\n4 MULTIPOLYGON (((-132.71 54....\n5 MULTIPOLYGON (((-171.7317 6...\n6 MULTIPOLYGON (((87.35997 49...\n```\n:::\n:::\n\n\n- plot 함수를 이용해서 기본 지도 만들기\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(world[3:6])\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(world[\"pop\"])\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n- 다른 지도층을 추가하기\n  - plot() 함수 내에 add = TRUE 매개변수를 사용하면 나중에 그 위에 다른 지도를 겹쳐서,\n    즉 층을 추가하여 지도를 덮어쓰기로 그릴 수 있음\n  - 단, 첫번째 지도 그래프에 키(key)가 있을 경우에는 reset = FALSE 매개변수를 꼭 설정해준 다음에,\n    이후에 다음번 plot(add = TRUE)를 사용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nworld_asia = world[world$continent == \"Asia\", ]\nasia = st_union(world_asia) #아시아 국가 합치기\n\n### 아시아만 빨간색으로 표시\nplot(world[\"pop\"], reset = FALSE) #reset = FLASE이면 지도 요소를 더 추가할 수 있는 모드로 플롯을 유지\nplot(asia, add = TRUE, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n### Base Plot arguments\n- 대륙별 중심점에 원을 덮어 씌우기\n  - st_centroid() : 폴리곤의 중심점을 계산하는 함수\n  - of_largest = TRUE : if `TRUE`, return centroid of the largest (sub)polygon of a `MULTIPOLYGON` rather than of the whole`MULTIPOLYGON`\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nplot(world[\"continent\"], reset = FALSE)\ncex = sqrt(world$pop) / 10000                         # pop변수에 제곱근을 취하고 1000으로 나누어서 지도 시각화를 위해 크기를 맞춤\nworld_cents = st_centroid(world, of_largest = TRUE)   # 다각형(국가별) 중앙점 계산\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: st_centroid assumes attributes are constant over geometries\n```\n:::\n\n```{.r .cell-code}\nplot(st_geometry(world_cents), add = TRUE, cex = cex) # 인구크기에 따라 대륙별 중앙점에 원그려넣기\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n- 특정 나라를 중심으로 확장하여 주변 나라 표시하기\n  - lwd : 선굵기\n  - world_asia[0] : 아시아에 대한 geometry column\n  - expandBB : 각 방향으로 경계 상자를 확장(아래, 왼쪽, 위, 오른쪽)\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nindia = world[world$name_long == \"India\", ]\nplot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = \"gray\", lwd = 3)\nplot(world_asia[0], add = TRUE)\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n## Geometry types\n- sf 패키지에서 지원하는 [17개의 geometry types](http://postgis.net/docs/using_postgis_dbmanagement.html)이 있음\n\n\n## Simple feature geometries(sfg)\n\n- sfg는 \"Simple Feature Geometries\"의 약어로, 공간 데이터의 기하학적 특성을 표현하는 방법 중 하나\n- sfg는 지오메트리 객체를 나타내며, 일반적으로 점(Point), 선(Line), 면(Polygon) 등과 같은 기본 기하학적 요소를 포함\n  - 예를 들어, 도로 네트워크를 나타내는 경우, 각 도로는 점과 선으로 구성된 지오메트리 객체로 표현됨\n- R에서 simple feature geometry types\n    - A point:`st_point()`\n    - A linestring:`st_linestring()`\n    - A polygon:`st_polygon()`\n    - A multipoint:`st_multipoint()`\n    - A multilinestring:`st_multilinestring()`\n    - A multipolygon:`st_multipolygon()`\n    - A geometry collection:`st_geometrycollection()`\n    \n- `sfg` objects can be created from 3 base R data types:\n1. A numeric vector : a single point\n2. A matrix : a set of points, where each row represents a point, a multipoint or linestring\n3. A list : a collection of objects such as matrices, multilinestrings or geometry collections\n\n\n### st_point()\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_point(c(5, 2))                 # XY point\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (5 2)\n```\n:::\n\n```{.r .cell-code}\nst_point(c(5, 2, 3))              # XYZ point\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT Z (5 2 3)\n```\n:::\n\n```{.r .cell-code}\nst_point(c(5, 2, 1), dim = \"XYM\") # XYM point\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT M (5 2 1)\n```\n:::\n\n```{.r .cell-code}\nst_point(c(5, 2, 3, 1))           # XYZM point\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT ZM (5 2 3 1)\n```\n:::\n:::\n\n\n### multipoint (`st_multipoint()`) and linestring (`st_linestring()`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### MULTIPOINT\nmultipoint_matrix <- rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))\nst_multipoint(multipoint_matrix)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTIPOINT ((5 2), (1 3), (3 4), (3 2))\n```\n:::\n\n```{.r .cell-code}\n### LINESTRING\nlinestring_matrix <- rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))\nst_linestring(linestring_matrix)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)\n```\n:::\n:::\n\n\n### list를 사용 : multilinestrings, (multi-)polygons and geometry collections\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## POLYGON\npolygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\nst_polygon(polygon_list)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n```\n:::\n\n```{.r .cell-code}\n## POLYGON with a hole\npolygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))\npolygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))\npolygon_with_hole_list = list(polygon_border, polygon_hole)\nst_polygon(polygon_with_hole_list)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))\n```\n:::\n\n```{.r .cell-code}\n## MULTILINESTRING\nmultilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                            rbind(c(1, 2), c(2, 4)))\nst_multilinestring((multilinestring_list))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n```\n:::\n\n```{.r .cell-code}\n## MULTIPOLYGON\nmultipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),\n                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))\nst_multipolygon(multipolygon_list)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))\n```\n:::\n\n```{.r .cell-code}\n## GEOMETRYCOLLECTION\ngemetrycollection_list = list(st_multipoint(multipoint_matrix),\n                              st_linestring(linestring_matrix))\nst_geometrycollection(gemetrycollection_list)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nGEOMETRYCOLLECTION (MULTIPOINT ((5 2), (1 3), (3 4), (3 2)), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))\n```\n:::\n:::\n\n\n\n## Simple feature columns(sfc)\n\n- 두 개의 지리특성(features)를 하나의 칼럼 객체로 합침\n- SFC는 \"Simple Feature Columns\"의 약어로, 공간 데이터를 표현하는 방법 중 하나\n- SFC는 일반적으로 지리 정보 시스템(GIS)에서 사용되며, 지도 및 공간 데이터를 저장하고 분석하는 데 사용됨\n- SFC는 일반적으로 공간 데이터를 테이블 형태로 나타내며, 각 행은 하나의 공간 객체를 나타냄\n  - 예를 들어, 도시의 경계를 포함하는 행정 구역 데이터를 저장할 때,\n    각 행은 구역의 이름, 인구, 경계 등을 포함하는 속성 데이터와 함께 구역의 경계를 나타내는 지오메트리 데이터를 포함\n  - sfc와 sfg는 공간 데이터를 다루는 데 사용되는 서로 다른 개념.\n    sfc는 공간 데이터를 저장하고 관리하는 방법을 나타내며, sfg는 공간 데이터의 기하학적 특성을 표현하는 방법을 나타냄\n  - sfc 공간 데이터를 sfg공간 데이터로 변경할 때 st_sfc() 함수를 사용\n\n\n- 1. 두개의 단순 지리특성 기하 점(2 sfg points)를 st_sfc() 함수로 한개의 단순 지리특성 칼럼(1 sfc)객체로 합치기\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### sfc POINT\npoint1 <- st_point(c(5, 2))\npoint1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (5 2)\n```\n:::\n\n```{.r .cell-code}\npoint2 <- st_point(c(1, 3))\npoint2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (1 3)\n```\n:::\n\n```{.r .cell-code}\npoints_sfc <- st_sfc(point1, point2)\npoints_sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 2 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\nCRS:           NA\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (5 2)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (1 3)\n```\n:::\n:::\n\n\n- 2. 두개의 단순 지리특성 기하 면(2 sfg polygons)를 st_sfc() 함수로 한개의 단순 지리특성 칼럼(1 sfc) 객체로 합치기\n  - st_geometry_type() : 기하유형을 확인\n  \n  \n\n::: {.cell}\n\n```{.r .cell-code}\n### sfc POLYGON\npolygon_list1 <- list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))\npolygon_list1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     [,1] [,2]\n[1,]    1    5\n[2,]    2    2\n[3,]    4    1\n[4,]    4    4\n[5,]    1    5\n```\n:::\n\n```{.r .cell-code}\npolygon1 <- st_polygon(polygon_list1)\npolygon1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n```\n:::\n\n```{.r .cell-code}\npolygon_list2 <- list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))\npolygon_list2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     [,1] [,2]\n[1,]    0    2\n[2,]    1    2\n[3,]    1    3\n[4,]    0    3\n[5,]    0    2\n```\n:::\n\n```{.r .cell-code}\npolygon2 <- st_polygon(polygon_list2)\npolygon2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((0 2, 1 2, 1 3, 0 3, 0 2))\n```\n:::\n\n```{.r .cell-code}\npolygon_sfc <- st_sfc(polygon1, polygon2)\npolygon_sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 2 features \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 0 ymin: 1 xmax: 4 ymax: 5\nCRS:           NA\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOLYGON ((0 2, 1 2, 1 3, 0 3, 0 2))\n```\n:::\n\n```{.r .cell-code}\nst_geometry_type(polygon_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] POLYGON POLYGON\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n:::\n\n```{.r .cell-code}\n### sfc MULTILINESTRING\nmultilinestring_list1 <- list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), \n                             rbind(c(1, 2), c(2, 4)))\nmultilinestring_list1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     [,1] [,2]\n[1,]    1    5\n[2,]    4    4\n[3,]    4    1\n[4,]    2    2\n[5,]    3    2\n\n[[2]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nmultilinestring1 <- st_multilinestring((multilinestring_list1))\nmultilinestring1\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))\n```\n:::\n\n```{.r .cell-code}\nmultilinestring_list2 <- list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), \n                             rbind(c(1, 7), c(3, 8)))\nmultilinestring_list2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     [,1] [,2]\n[1,]    2    9\n[2,]    7    9\n[3,]    5    6\n[4,]    4    7\n[5,]    2    7\n\n[[2]]\n     [,1] [,2]\n[1,]    1    7\n[2,]    3    8\n```\n:::\n\n```{.r .cell-code}\nmultilinestring2 <- st_multilinestring((multilinestring_list2))\nmultilinestring2\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTILINESTRING ((2 9, 7 9, 5 6, 4 7, 2 7), (1 7, 3 8))\n```\n:::\n\n```{.r .cell-code}\nmultilinestring_sfc <- st_sfc(multilinestring1, multilinestring2)\nmultilinestring_sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 2 features \nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 1 ymin: 1 xmax: 7 ymax: 9\nCRS:           NA\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 ...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTILINESTRING ((2 9, 7 9, 5 6, 4 7, 2 7), (1 ...\n```\n:::\n\n```{.r .cell-code}\nst_geometry_type(multilinestring_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] MULTILINESTRING MULTILINESTRING\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n:::\n:::\n\n\n\n- 3. 단순 지리특성 기하 점과 면을 st_sfc() 함수로 합쳐서 한개의 단순 지리특성 칼럼(1 sfc) 객체로 만들기\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### sfc GEOMETRY\npoint_multilinestring_sfc <- st_sfc(point1, multilinestring1)\npoint_multilinestring_sfc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 2 features \nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 1 ymin: 1 xmax: 5 ymax: 5\nCRS:           NA\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (5 2)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nMULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 ...\n```\n:::\n\n```{.r .cell-code}\nst_geometry_type(point_multilinestring_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] POINT           MULTILINESTRING\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n:::\n:::\n\n\n- sfc 객체는 CRS(coordinate reference systems, 좌표계시스템) 에 대한 정보를 추가로 저장할 수 있음\n  - 특정 CRS를 지정하기 위해 (a)epsg (SRID)또는(b)proj4string속성을 사용할수 있음\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(points_sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System: NA\n```\n:::\n:::\n\n\n\n### - 좌표계 정보를 추가하는 방법\n\n- 1. epsg 코드를 입력\n- epsg 코드 장점\n  - 짧아서 기억하기 쉬움\n  - EPSG : European Petroleum Survey Group, 지도 투영과 datums 에 대한 좌표계 정보 데이터베이스를 제공\n- `sfc` 객체 내에 모든 geometries는 동일한 CRS를 가져야함\n- `epsg` code 를 `4326` 로 설정\n- EPSG:4326 → WGS84 경위도: GPS가 사용하는 좌표계\n  - 서비스: 구글 지구(Google Earth)\n  - 단위: 소수점 (decimal degrees)\n  - `+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs`\n  \n\n::: {.cell}\n\n```{.r .cell-code}\n### EPSG definition\npoints_sfc_wgs <- st_sfc(point1, point2, crs = 4326)\nst_crs(points_sfc_wgs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:4326 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n        MEMBER[\"World Geodetic System 1984 (Transit)\"],\n        MEMBER[\"World Geodetic System 1984 (G730)\"],\n        MEMBER[\"World Geodetic System 1984 (G873)\"],\n        MEMBER[\"World Geodetic System 1984 (G1150)\"],\n        MEMBER[\"World Geodetic System 1984 (G1674)\"],\n        MEMBER[\"World Geodetic System 1984 (G1762)\"],\n        MEMBER[\"World Geodetic System 1984 (G2139)\"],\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ENSEMBLEACCURACY[2.0]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"geodetic latitude (Lat)\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"geodetic longitude (Lon)\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    USAGE[\n        SCOPE[\"Horizontal component of 3D system.\"],\n        AREA[\"World.\"],\n        BBOX[-90,-180,90,180]],\n    ID[\"EPSG\",4326]]\n```\n:::\n:::\n\n\n\n- 2. PROJ.4 문자열을 직접 입력\n- proj4string 장단점\n  - 투사 유형이나 datum, 타원체 등의 다른 모수들을 구체화할 수 있는 유연성이 있음\n  - 사용자가 구체화를 해야 하므로 길고 복잡하며 기억하기 어려움\n  - `proj4string`은 문자열 형식으로 저장되며, 일반적으로 PROJ.4 라이브러리에서 사용하는 형식과 호환됨\n  - 이 문자열에는 좌표계의 이름, 중앙 메리디언, 기준 위도 및 경도, 원점 위도 및 경도, 스케일링 요소 등의 정보가 포함\n    - 예를 들어, WGS 84 좌표계의 `proj4string`은 다음과 같이 표시됨\n  - `proj4string`을 변경하면 공간 데이터를 다른 좌표계로 변환 가능\n\n\n- `st_transform()` 함수를 사용하여 다른 좌표계로 변환가능\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### PROJ4STRING definition\nst_sfc(point1, point2, crs = \"+proj=longlat +datum=WGS84 +no_defs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 2 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 1 ymin: 2 xmax: 5 ymax: 3\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (5 2)\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (1 3)\n```\n:::\n:::\n\n\n## sf class\n- 위의 위치데이터에 속성데이터(이름, 특정 값, 그룹 등)를 추가\n\n- 아래 예시는 2017년 6월 21일 런던의 25°C 온도를 나타냄\n\n- a geometry (the coordinates), and three attributes with three different classes (place name, temperature and date)\n\n- simple feature geometry column (`sfc` )에 속성(data.frame)을 나타내는 sf(simple features)의 calss를 합침\n\n- `st_sf()` 를 이용하여 sfc와 class sf의 객체들을 하나로 통합할 수 있음\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlnd_point <- st_point(c(0.1, 51.5)) \nlnd_point                                           # sfg object\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (0.1 51.5)\n```\n:::\n\n```{.r .cell-code}\nlnd_geom <- st_sfc(lnd_point, crs = 4326)           # sfc object\nlnd_geom\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 1 feature \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\nGeodetic CRS:  WGS 84\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPOINT (0.1 51.5)\n```\n:::\n\n```{.r .cell-code}\nlnd_attrib <- data.frame(                           # data.frame object\n  name = \"London\",\n  temperature = 25,\n  date = as.Date(\"2017-06-21\"))\nlnd_attrib\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    name temperature       date\n1 London          25 2017-06-21\n```\n:::\n\n```{.r .cell-code}\nlnd_sf <- st_sf(lnd_attrib, geometry = lnd_geom)    # sf object\nlnd_sf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0.1 ymin: 51.5 xmax: 0.1 ymax: 51.5\nGeodetic CRS:  WGS 84\n    name temperature       date         geometry\n1 London          25 2017-06-21 POINT (0.1 51.5)\n```\n:::\n\n```{.r .cell-code}\nlnd_sf %>% class()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\n1. `sfg` (simple feature geometry) 를 만듬\n\n2.  CRS(좌표계시스템)를 가지는 `sfc` (simple feature geometry column)으로 전환\n\n3. `st_sf()` 를 이용하여`data.frame` 에 저장된 속성 정보와 `sfc` 를 통합\n\n\n\n## 래스터 (Raster) data\n- 지리적 레스터 데이터 모델은 래스터 헤더와 일반적으로 동일한 간격의 셀(픽셀)을 나타내는 matrix로 구성됨\n  - Raster header : 좌표 참조 시스템(CRS, Coordinate Reference System),           시작점(the origin)과 범위 (the extent)를 정의함\n    - 헤더는 열 수, 행 수 및 셀 크기 해상도를 통해 범위를 정의\n    - 셀의 ID를 사용하여 각 단일 셀에 쉽게 접근하고 수정\n  - 행렬 (matrix) :  동일한 크기의 픽셀 또는 셀(pixel, or cell)을 표현. 픽셀      ID(pixel IDs)와 픽셀 값(pixel values)\n\n- 원점(또는 시작점)은 종종 행렬의 왼쪽 아래 모서리 좌표(R의 래스터 패키지는 기본적으로 왼쪽 위 모서리를 사용)\n\n- 래스터 레이어의 셀에는 단일 값(숫자 또는 범주)만 포함\n\n\n## An introduction to raster\n- raster package는 R에서 raster objects을 만들고, 읽고, 내보내고, 조작 및 처리하기 위한 광범위한 기능을 제공\n\n- 래스터 개념을 설명하기 위해 spDataLarge의 데이터 세트를 사용\n\n- Zion National Park(미국 유타) 지역을 덮는 몇 개의 래스터 개체와 하나의 벡터 개체로 구성\n\n- `srtm.tif`은 이 지역의 디지털 표고 모델\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install.packages(\"rgdal\") \nlibrary(rgdal)\n\n#install.packages(\"spDataLarge\",repos = \"https://nowosad.github.io/drat/\",type = \"source\") #지리공간 데이터 샘플을 내장\n#install.packages(\"raster\")\n\nlibrary(spDataLarge)\nlibrary(raster)\n\nraster_filepath <- system.file(\"raster/srtm.tif\", package = \"spDataLarge\") \nraster_filepath\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/seong taek/AppData/Local/R/win-library/4.2/spDataLarge/raster/srtm.tif\"\n```\n:::\n\n```{.r .cell-code}\nnew_raster <- raster(raster_filepath)\nnew_raster\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 457, 465, 212505  (nrow, ncol, ncell)\nresolution : 0.0008333333, 0.0008333333  (x, y)\nextent     : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : srtm.tif \nnames      : srtm \nvalues     : 1024, 2892  (min, max)\n```\n:::\n\n```{.r .cell-code}\n# 클래스(class)\n# 차원(dimentions)\n# 해상도(resolution)\n# 범위(extent)\n# 좌표 참조 시스템 (Coordinates Reference System)\n# 출처(Source)\n# 이름(names)\n# 최소/최대 값(min, max values) 속성 정보\n\n### rgdal 설치 error발생시 rgdal 설치및로드 필요\n```\n:::\n\n\n### Functions\n- `dim()`: returns the number of rows, columns and layers\n- `ncell()`: function the number of cells (pixels)\n- `res()`: the raster’s spatial resolution\n- `extent()`: its spatial extent\n- `crs()`: coordinate reference system\n- `inMemory()`: reports whether the raster data is stored in memory (the default) or on disk\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 457 465   1\n```\n:::\n\n```{.r .cell-code}\nncell(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 212505\n```\n:::\n\n```{.r .cell-code}\nextent(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : Extent \nxmin       : -113.2396 \nxmax       : -112.8521 \nymin       : 37.13208 \nymax       : 37.51292 \n```\n:::\n\n```{.r .cell-code}\ncrs(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\nDeprecated Proj.4 representation: +proj=longlat +datum=WGS84 +no_defs \nWKT2 2019 representation:\nGEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]] \n```\n:::\n\n```{.r .cell-code}\ninMemory(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# help(\"raster-package\")\n```\n:::\n\n\n## Basic map making\n\n- sf package와 같이 raster 역시`plot()` 함수 사용 가능\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(new_raster)\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n## Raster classes\n3가지의레스터 클래스(Raster Classes)의 특장점\n\n**(1) RasterLayer class**\n\n**(2) RasterBrick class**\n\n**(3) RasterStack class**\n\n### 1. RasterLayer class\n\n- `RasterLayer` class는 래스터 객체 중에서 가장 간단한 형태의 클래스이며, 한개의 층으로 구성되어 있음\n\n- RasterLayer Class 객체를 만드는 가장 쉬운 방법은 기존의 RasterLayer Class 객체 파일을 읽어오는 것\n  - 아래 예에서는 raster 패키지의 raster() 함수를 사용해서\n      spDataLarge 패키지에 내장되어 있는 srtm.tif 레스터 층 클래스 객체를 읽어와서\n      raster_layer 라는 이름의 단 한개의 층만을 가진 RasterLayer Class 객체를 만듬\n  - nlayers() 함수로 층의 개수를 살펴보면 '1'개 인 것을 확인할 수 있습니다.\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_filepath <- system.file(\"raster/srtm.tif\", package = \"spDataLarge\")\nraster_filepath\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/seong taek/AppData/Local/R/win-library/4.2/spDataLarge/raster/srtm.tif\"\n```\n:::\n\n```{.r .cell-code}\nnew_raster <- raster(raster_filepath)\nnew_raster\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 457, 465, 212505  (nrow, ncol, ncell)\nresolution : 0.0008333333, 0.0008333333  (x, y)\nextent     : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : srtm.tif \nnames      : srtm \nvalues     : 1024, 2892  (min, max)\n```\n:::\n\n```{.r .cell-code}\n### number of layers \nnlayers(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n- RasterLayer 클래스 객체를 raster() 함수를 사용해서 처음부터 직접 만들 수도 있음\n  - 8개의 행과 8개의 열, 총 64개의 셀(픽셀)을 가진 RasterLayer 클래스를 직접 만들기\n  - 레스터 객체의 좌표 참조 시스템(CRS, Coordinates Reference System)은 **WGS84 가 기본 설정값(해상도(resolution)의 단위가 도 (in degrees))**\n  - res = 0.5 로서 해상도를 0.5도로 설정\n  - 각 셀의 값은 왼쪽 상단부터 시작하여, 행 방향(row-wise)으로 왼쪽에서 오른쪽으로 채워짐\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_raster <- raster(nrows = 8, ncols = 8, res = 0.5, \n                   xmn = -2.0, xmx = 2.0, ymn = -2.0, ymx = 2.0, vals = 1:64)\nmy_raster\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 8, 8, 64  (nrow, ncol, ncell)\nresolution : 0.5, 0.5  (x, y)\nextent     : -2, 2, -2, 2  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      : layer \nvalues     : 1, 64  (min, max)\n```\n:::\n\n```{.r .cell-code}\n## plotting \nplot(my_raster, main = \"my raster (64 cells = 8 rows * 8 cols)\")           \n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n\n### 2. RasterBrick class\n- `RasterBrick`and`RasterStack` 클래스는 **여러 개의 층(multiple layers)**을 가질 수 있음\n\n- 특히, `RasterBrick` 클래스는 **단일 다중 스펙트럼 위성 파일 (a single multispectral satellite file)** 이나 또는 **메모리의 단일 다층 객체 (a single multilayer object in memory)**의 형태로 **다층의 레스터 객체**를 구성\n\n- 아래의 예는 raster 패키지의 `brick()`**함수를 사용**해서 spDataLarge 패키지에 들어있는 **landsat.tif** **의 다층 레스터 파일**을 `RasterBrick`클래스 객체로 불러온 것\n  - `nlayers()` : the number of layers stored in a `Raster*`  object\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nmulti_raster_file <- system.file(\"raster/landsat.tif\", package = \"spDataLarge\")\nmulti_raster_file\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/seong taek/AppData/Local/R/win-library/4.2/spDataLarge/raster/landsat.tif\"\n```\n:::\n\n```{.r .cell-code}\nr_brick <- brick(multi_raster_file)\nr_brick\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterBrick \ndimensions : 1428, 1128, 1610784, 4  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs \nsource     : landsat.tif \nnames      : landsat_1, landsat_2, landsat_3, landsat_4 \nmin values :      7550,      6404,      5678,      5252 \nmax values :     19071,     22051,     25780,     31961 \n```\n:::\n\n```{.r .cell-code}\nnlayers(r_brick)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nplot(r_brick) #plotting RasterBrick object with 4 layers\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n### 3. RasterStack class\n- **다 층 (multi-layers) 레스터 객체**로 구성\n\n- **같은 범위와 해상도**를 가진 **여러개의 `RasterLayer` 클래스 객체**들을 **리스트**로 묶어서 `RasterStack` 클래스 객체를 만듬\n\n- `RasterBrick`클래스가 동일한 복수개의  `RasterLayer`층으로 구성되는 반면에, `RasterStack`클래스는 여러개의  `RasterLayer`와`RasterBrick` 클래스 객체가 혼합되어서 구성할 수 있음\n\n- 연산 속도면에서 보면 일반적으로 `RasterBrick`  클래스가 `RasterStack` 클래스보다 빠름\n\n- 아래 예시\n    - (a) raster(raster_brick, layer = 1) 함수를 사용해서 위에서 불러왔던 RasterBrick 클래스 객체의 1번째 층만 가져다가 raster_on_disk 라는 이름으로 레스터 객체를 하나 만듬\n    - (b) raster() 함수로 동일한 범위와 해상도, 좌표 참조 시스템(CRS)를 가지고 난수로 셀의 값을 채운 raster_in_memory 라는 이름의 메모리에 있는 RasterLayer 클래스 객체를 만듬\n        - seq_len(n) : 1부터 n까지 입력(1씩 커짐)\n    - 다음에 stac() 함수로 raster_stack = stack(raster_in_memory, raster_on_disk) 처럼 (a) + (b) 하여 쌓아서 raster_stack 라는 이름의 RasterStack 클래스 객체를 만듬\n    - 마지막으로 **plot() 함수**로 RasterStack 클래스 객체에 쌓여 있는 2개의 객체를 시각화 (raster_in_memory 는 난수를 발생시켜 셀 값을 채웠기 때문에 시각화했을 때 아무런 패턴이 없음)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_on_disk <- raster(r_brick, layer = 1)\nraster_on_disk\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \nband       : 1  (of  4  bands)\ndimensions : 1428, 1128, 1610784  (nrow, ncol, ncell)\nresolution : 30, 30  (x, y)\nextent     : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs \nsource     : landsat.tif \nnames      : landsat_1 \nvalues     : 7550, 19071  (min, max)\n```\n:::\n\n```{.r .cell-code}\nraster_in_memory = raster(xmn = 301905, xmx = 335745,\n                          ymn = 4111245, ymx = 4154085, \n                          res = 30)\nraster_in_memory\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 1428, 1128, 1610784  (nrow, ncol, ncell)\nresolution : 30, 30  (x, y)\nextent     : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\ncrs        : NA \n```\n:::\n\n```{.r .cell-code}\nvalues(raster_in_memory) <- sample(seq_len(ncell(raster_in_memory)))\n\ncrs(raster_in_memory) = crs(raster_on_disk) #같은 좌표 입력\n\nr_stack <- stack(raster_in_memory, raster_on_disk)\nr_stack\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterStack \ndimensions : 1428, 1128, 1610784, 2  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs \nnames      :   layer, landsat_1 \nmin values :       1,      7550 \nmax values : 1610784,     19071 \n```\n:::\n\n```{.r .cell-code}\nplot(r_stack)\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n### 언제 어떤 래스터 클래스를 사용하는 것이 좋은가?\n\n- **하나의 다층 레스터 파일이나 객체**(a single multilayer file or object)를 처리하는 것이라면 **RasterBrick 이 적합**\n\n- 반면에, **여러개의 래스터 파일들(many files)**이나 **여러 종류의 레스터 클래스**를 한꺼번에 연결해서 연산하고 처리해야 하는 경우라면 **RasterStack Class 가 적합**\n\n\n## **Coordinate Reference Systems**\n\n## CRS(Coordinate Reference Systems)\n- 지리 공간 데이터 분석에서 가장 기본이 되고 또 처음에 확인을 해보아야 하는 좌표계, **좌표 참조 시스템(CRS, Coordinate Reference Systems**)에 대한 소개\n    - **지리 좌표계** (Geographic Coordinate Reference Systems)\n    - **투영(투사) 좌표계** (Projected Coordinate Reference Systems)\n    \n\n## CRS in R\n- R에서 좌표계를 표현할 때는 (a) **epsg 코드 (epsg code)**나 또는 (b)**proj4string 정의 (proj4string definition)**를 사용\n\n- R에서 CRS를 설명하는 두 가지 주요 방법은(a) `epsg`코드 또는(b)`proj4string`정의\n\n- `epsg`코드\n    - 일반적으로 더 짧으므로 기억하기 쉬움\n    - 또한 이 코드는 잘 정의된 좌표 참조 시스템을 하나만 참조\n    \n- `proj4string`정의\n    - 투영 유형, 데이텀 및 타원체와 같은 다양한 매개변수를 지정할 때 **더 많은 유연성**을 얻을 수 있음\n    - 다양한 투영을 지정하고 기존 투영을 수정할 수 있음 (이것은 또한 `proj4string`접근 방식을 더 복잡하게 만듬)\n    \n- 벡터 데이터의 좌표계\n    - 벡터 지리 데이터에 대해서는 sf 패키지의 ****`st_crs()`**함수**를 사용해서 좌표계를 확인\n    - spDataLarge 패키지에 들어있는 Zion 국립 공원의 경계를 다각형면(Polygon)으로 나타내는 zion.gpkg 벡터 데이터를 **st_read() 함수**로 불러와서, `st_crs()`**함수로 좌표계를 조회**\n    \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n\nvector_filepath <- system.file(\"vector/zion.gpkg\", package = \"spDataLarge\")\nvector_filepath\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/seong taek/AppData/Local/R/win-library/4.2/spDataLarge/vector/zion.gpkg\"\n```\n:::\n\n```{.r .cell-code}\nnew_vector <- st_read(vector_filepath)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `zion' from data source \n  `C:\\Users\\seong taek\\AppData\\Local\\R\\win-library\\4.2\\spDataLarge\\vector\\zion.gpkg' \n  using driver `GPKG'\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 302903.1 ymin: 4112244 xmax: 334735.5 ymax: 4153087\nProjected CRS: UTM Zone 12, Northern Hemisphere\n```\n:::\n\n```{.r .cell-code}\nnew_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 302903.1 ymin: 4112244 xmax: 334735.5 ymax: 4153087\nProjected CRS: UTM Zone 12, Northern Hemisphere\n  UNIT_CODE\n1      ZION\n                                                                            GIS_Notes\n1 Lands - http://landsnet.nps.gov/tractsnet/documents/ZION/Metadata/zion_metadata.xml\n           UNIT_NAME  DATE_EDIT STATE REGION GNIS_ID     UNIT_TYPE CREATED_BY\n1 Zion National Park 2017-06-22    UT     IM 1455157 National Park      Lands\n                                                                   METADATA\n1 https://irma.nps.gov/App/Reference/Profile/2181118#Zion National Monument\n  PARKNAME                           geom\n1     Zion POLYGON ((314945.2 4115910,...\n```\n:::\n\n```{.r .cell-code}\n## st_read() : read vector dataset in R sf package\n\nst_crs(new_vector) # get CRS\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: UTM Zone 12, Northern Hemisphere \n  wkt:\nBOUNDCRS[\n    SOURCECRS[\n        PROJCRS[\"UTM Zone 12, Northern Hemisphere\",\n            BASEGEOGCRS[\"GRS 1980(IUGG, 1980)\",\n                DATUM[\"unknown\",\n                    ELLIPSOID[\"GRS80\",6378137,298.257222101,\n                        LENGTHUNIT[\"metre\",1,\n                            ID[\"EPSG\",9001]]]],\n                PRIMEM[\"Greenwich\",0,\n                    ANGLEUNIT[\"degree\",0.0174532925199433]]],\n            CONVERSION[\"UTM zone 12N\",\n                METHOD[\"Transverse Mercator\",\n                    ID[\"EPSG\",9807]],\n                PARAMETER[\"Latitude of natural origin\",0,\n                    ANGLEUNIT[\"degree\",0.0174532925199433],\n                    ID[\"EPSG\",8801]],\n                PARAMETER[\"Longitude of natural origin\",-111,\n                    ANGLEUNIT[\"degree\",0.0174532925199433],\n                    ID[\"EPSG\",8802]],\n                PARAMETER[\"Scale factor at natural origin\",0.9996,\n                    SCALEUNIT[\"unity\",1],\n                    ID[\"EPSG\",8805]],\n                PARAMETER[\"False easting\",500000,\n                    LENGTHUNIT[\"Meter\",1],\n                    ID[\"EPSG\",8806]],\n                PARAMETER[\"False northing\",0,\n                    LENGTHUNIT[\"Meter\",1],\n                    ID[\"EPSG\",8807]],\n                ID[\"EPSG\",16012]],\n            CS[Cartesian,2],\n                AXIS[\"(E)\",east,\n                    ORDER[1],\n                    LENGTHUNIT[\"Meter\",1]],\n                AXIS[\"(N)\",north,\n                    ORDER[2],\n                    LENGTHUNIT[\"Meter\",1]]]],\n    TARGETCRS[\n        GEOGCRS[\"WGS 84\",\n            DATUM[\"World Geodetic System 1984\",\n                ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                    LENGTHUNIT[\"metre\",1]]],\n            PRIMEM[\"Greenwich\",0,\n                ANGLEUNIT[\"degree\",0.0174532925199433]],\n            CS[ellipsoidal,2],\n                AXIS[\"latitude\",north,\n                    ORDER[1],\n                    ANGLEUNIT[\"degree\",0.0174532925199433]],\n                AXIS[\"longitude\",east,\n                    ORDER[2],\n                    ANGLEUNIT[\"degree\",0.0174532925199433]],\n            ID[\"EPSG\",4326]]],\n    ABRIDGEDTRANSFORMATION[\"Transformation from GRS 1980(IUGG, 1980) to WGS84\",\n        METHOD[\"Position Vector transformation (geog2D domain)\",\n            ID[\"EPSG\",9606]],\n        PARAMETER[\"X-axis translation\",0,\n            ID[\"EPSG\",8605]],\n        PARAMETER[\"Y-axis translation\",0,\n            ID[\"EPSG\",8606]],\n        PARAMETER[\"Z-axis translation\",0,\n            ID[\"EPSG\",8607]],\n        PARAMETER[\"X-axis rotation\",0,\n            ID[\"EPSG\",8608]],\n        PARAMETER[\"Y-axis rotation\",0,\n            ID[\"EPSG\",8609]],\n        PARAMETER[\"Z-axis rotation\",0,\n            ID[\"EPSG\",8610]],\n        PARAMETER[\"Scale difference\",1,\n            ID[\"EPSG\",8611]]]]\n```\n:::\n:::\n\n\n- 좌표계가 비어있거나 잘못 입력되어 있는 경우 `**st_set_crs(vector_object,EPSG code)`** 구문으로 **좌표계를 설정**할수 있음\n\n- `**st_set_crs()**` 함수는 좌표계를 변경하는 것이 투영 데이터를 변환하는 것은 아니며, **투영 데이터 변환을 하려면 st_transform() 함수**를 이용\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## -- st_set_crs() : setting a CRS (coordinate reference system) \nnew_vector_2 <- st_set_crs(new_vector, 4326) # set CRS with EPSG 4326 code\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: st_crs<- : replacing crs does not reproject data; use st_transform for\nthat\n```\n:::\n\n```{.r .cell-code}\nnew_vector_2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 302903.1 ymin: 4112244 xmax: 334735.5 ymax: 4153087\nGeodetic CRS:  WGS 84\n  UNIT_CODE\n1      ZION\n                                                                            GIS_Notes\n1 Lands - http://landsnet.nps.gov/tractsnet/documents/ZION/Metadata/zion_metadata.xml\n           UNIT_NAME  DATE_EDIT STATE REGION GNIS_ID     UNIT_TYPE CREATED_BY\n1 Zion National Park 2017-06-22    UT     IM 1455157 National Park      Lands\n                                                                   METADATA\n1 https://irma.nps.gov/App/Reference/Profile/2181118#Zion National Monument\n  PARKNAME                           geom\n1     Zion POLYGON ((314945.2 4115910,...\n```\n:::\n\n```{.r .cell-code}\n# 경고 메세지 확인\n```\n:::\n\n\n- 래스터 데이터에서 좌표계\n    - 레스터 모델의 객체에 대해서는 raster 패키지의 `projection()`\n     **함수를 사용**해서 좌표계를 확인하거나 설정\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## -- raster::projection() : get or set CRS in raster* objects \nlibrary(raster) \n\nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\") \nraster_filepath\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"C:/Users/seong taek/AppData/Local/R/win-library/4.2/spDataLarge/raster/srtm.tif\"\n```\n:::\n\n```{.r .cell-code}\nnew_raster = raster(raster_filepath)\nnew_raster\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 457, 465, 212505  (nrow, ncol, ncell)\nresolution : 0.0008333333, 0.0008333333  (x, y)\nextent     : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : srtm.tif \nnames      : srtm \nvalues     : 1024, 2892  (min, max)\n```\n:::\n\n```{.r .cell-code}\nprojection(new_raster) # get CRS in raster objects # [1] \"+proj=longlat +datum=WGS84 +no_defs\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"+proj=longlat +datum=WGS84 +no_defs\"\n```\n:::\n:::\n\n\n- 레스터 데이터에 대해서 좌표계를 새로 설정할 때도 역시 projection()함수를 사용\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_raster3  <-  new_raster\nnew_raster3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 457, 465, 212505  (nrow, ncol, ncell)\nresolution : 0.0008333333, 0.0008333333  (x, y)\nextent     : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : srtm.tif \nnames      : srtm \nvalues     : 1024, 2892  (min, max)\n```\n:::\n\n```{.r .cell-code}\nprojection(new_raster3) <-  \"+proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 \n                            +units=m +no_defs\" # set CRS\nnew_raster3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 457, 465, 212505  (nrow, ncol, ncell)\nresolution : 0.0008333333, 0.0008333333  (x, y)\nextent     : -113.2396, -112.8521, 37.13208, 37.51292  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=12 +ellps=GRS80 +units=m +no_defs \nsource     : srtm.tif \nnames      : srtm \nvalues     : 1024, 2892  (min, max)\n```\n:::\n:::\n\n- 벡터 데이터의 경우 좌표계를 설정할 때 'EPSG 코드'나 'Proj4string 정의' 모두 사용 가능한 반면에, 레스터 데이터는 **'Proj4string 정의**'만 사용\n\n- 중요한 것은 `st_crs()`및 `projection()`함수는 **좌표의 값이나 지오메트리를 변경하지 않음**\n\n\n## Unit(단위)\n- 좌표계 (CRS) 정보 안에 들어있는 **공간의 단위 (Spatial Units)**\n\n- 지도를 제작하거나 볼 때 측정 단위 (measurement units)가 **미터(meters) 인지 혹은 피트(feets)** 인지 명시적으로 표현하고 정확하게 확인할 필요\n\n- **벡터의 지리적 데이터나 레스터의 픽셀에서 측정되는 단위**라는 맥락(context)를 알 수 있고, 실제 지표면과 지도 표현 간의 관계, 거리를 알 수 있고, 또 거리나 면적 등을 계산할 수 있음\n\n(1) 지리공간 벡터 데이터의 측정 단위(Units in Vector data)\n\n- sf 객체의 지리공간 벡터 데이터는 단위에 대해서 native support 이여서, 다른 외부 모듈이나 확장 프로그램을 설치하지 않아도 **sf 객체 내에 단위가 들어가 있음**\n\n- 그래서 sf 객체 벡터 데이터에 대해서 연산을 하게 되면 units 패키지에 의해 정의된 \"단위 속성\"도 같이 반환해주어서 단위로 인한 혼란을 미연에 방지할 수 있음(대부분의         좌표계는 미터(meters)를 사용하지만, 일부는 피트(feets)를 사용하기 때문에 단위가 혼란스러울 수 있음. raster 패키지는 단위가 native support가 아님.)\n    - R의 spData 패키지에 들어있는 \"world\" 데이터셋을 활용하여 Luxembourgd와 대한민국의 벡터 데이터를 가져와서, st_area()함수로 면적을 계산\n    - sf 패키지의 **st_area() 함수로 벡터 데이터의 면적으로 계산** 하면, 결과값의 뒤에 **[m^2]** 이라고 해서 2차원 공간 상의 **\"제곱미터\" 단위**가 같이 반환\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spData)\n\nnames(world)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"iso_a2\"    \"name_long\" \"continent\" \"region_un\" \"subregion\" \"type\"     \n [7] \"area_km2\"  \"pop\"       \"lifeExp\"   \"gdpPercap\" \"geom\"     \n```\n:::\n\n```{.r .cell-code}\nluxembourg = world[world$name_long == \"Luxembourg\", ]\nluxembourg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 5.674052 ymin: 49.44267 xmax: 6.242751 ymax: 50.12805\nGeodetic CRS:  WGS 84\n# A tibble: 1 × 11\n  iso_a2 name_long  conti…¹ regio…² subre…³ type  area_…⁴    pop lifeExp gdpPe…⁵\n  <chr>  <chr>      <chr>   <chr>   <chr>   <chr>   <dbl>  <dbl>   <dbl>   <dbl>\n1 LU     Luxembourg Europe  Europe  Wester… Sove…   2417. 556319    82.2  93655.\n# … with 1 more variable: geom <MULTIPOLYGON [°]>, and abbreviated variable\n#   names ¹​continent, ²​region_un, ³​subregion, ⁴​area_km2, ⁵​gdpPercap\n```\n:::\n\n```{.r .cell-code}\nsouth_korea = world[world$name_long == \"Republic of Korea\", ] \nsouth_korea\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 1 feature and 10 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 126.1174 ymin: 34.39005 xmax: 129.4683 ymax: 38.61224\nGeodetic CRS:  WGS 84\n# A tibble: 1 × 11\n  iso_a2 name_long  conti…¹ regio…² subre…³ type  area_…⁴    pop lifeExp gdpPe…⁵\n  <chr>  <chr>      <chr>   <chr>   <chr>   <chr>   <dbl>  <dbl>   <dbl>   <dbl>\n1 KR     Republic … Asia    Asia    Easter… Sove…  99044. 5.07e7    81.7  33426.\n# … with 1 more variable: geom <MULTIPOLYGON [°]>, and abbreviated variable\n#   names ¹​continent, ²​region_un, ³​subregion, ⁴​area_km2, ⁵​gdpPercap\n```\n:::\n\n```{.r .cell-code}\nplot(south_korea)\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(south_korea[1])\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-30-2.png){width=672}\n:::\n\n```{.r .cell-code}\nst_area(luxembourg) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2408817306 [m^2]\n```\n:::\n\n```{.r .cell-code}\nst_area(south_korea)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n99020196082 [m^2]\n```\n:::\n:::\n\n\n\n\n- 면적 단위가 [m^2] 이다보니 결과값의 자리수가 너무 길게 표현됨\n\n- 계산의 단위를 “제곱킬로미터[km^2]로 변경하려면 units 패키지의 `set_units(st_object, units)` 함수로 단위를 설정할 수 있음\n\n- 기존의 면적 단위인 '제곱미터(m^2)' 로 계산된 결과값을 1,000,000 으로 나누게 되면 결과값은 맞더라도 단위가 '제곱미터(m^2)' 로 그대로여서, 우리가 원하던 단위인 '제곱킬로미터(km^2)' 가 아니게 되므로 주의가 필요\n\n\n(2) 지리공간 래스터 데이터의 측정 단위(Units in Raster data)\n\n- 벡터 데이터를 다루는 sf 패키지는 단위가 native support 여서 조회나 계산 결과를 반환할 때 단위(units)를 속성으로 반환\n\n- 하지만 레스터 데이터를 다루는 **raster 패키지**는 단위에 대해서 native support 가 아니므로, **단위에 대해서 혼란스러울 수 있으므로 조심**해야 함\n  - spDataLarge 패키지에 들어있는 strm.tif 파일을 raster() 함수로 읽어옴\n  - 이 데이터는 st_crs() 함수로 좌표계를 확인해보면 \"WGS84 투영\"을 사용하므로, 십진수 각도 (decimal degrees as units) 를 단위로 사용\n  - res() 함수로 해상도를 확인해보면, 단지 숫자형 벡터 (numeric vector) 만 반환할 뿐, 단위에 대한 속성 정보는 없음 (no units attributes)\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## -- units in raster data library(raster) \nlibrary(spDataLarge) \nraster_filepath = system.file(\"raster/srtm.tif\", package = \"spDataLarge\") \nnew_raster = raster(raster_filepath)\n\n## -- getting CRS \nst_crs(new_raster) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: +proj=longlat +datum=WGS84 +no_defs \n  wkt:\nGEOGCRS[\"unknown\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]],\n        ID[\"EPSG\",6326]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433],\n        ID[\"EPSG\",8901]],\n    CS[ellipsoidal,2],\n        AXIS[\"longitude\",east,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]],\n        AXIS[\"latitude\",north,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433,\n                ID[\"EPSG\",9122]]]]\n```\n:::\n\n```{.r .cell-code}\nplot(new_raster)\n```\n\n::: {.cell-output-display}\n![](공간정보분석-CH2_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n\n```{.r .cell-code}\nres(new_raster)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0008333333 0.0008333333\n```\n:::\n:::\n\n\n- UTM 투영을 사용한다면, 이에 따라서 단위가 바뀌지만, res()로 해상도를 살펴보면 역시 단지 숫자형 벡터만 반환할 뿐, 단위 속성 정보는 없음\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## -- if we used the UTM projection, the units would change. \nrepr <- projectRaster(new_raster, crs = \"+init=epsg:26912\") \n\n## -- no units attributes, just only returns numeric vector \nres(repr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 73.8 92.5\n```\n:::\n:::\n",
    "supporting": [
      "공간정보분석-CH2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}